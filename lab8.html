<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<script type="text/javascript">

var gl;

var shaderProgram;

var uPMatrix;

var vertexPositionBuffer;

var vertexColorBuffer;

var vertexCoordsBuffer;

var vertexNormalBuffer;



function MatrixMul(a,b) //Mnożenie macierzy

{

  let c = [

  0,0,0,0,

  0,0,0,0,

  0,0,0,0,

  0,0,0,0

  ]

  for(let i=0;i<4;i++)

  {

    for(let j=0;j<4;j++)

    {

      c[i*4+j] = 0.0;

      for(let k=0;k<4;k++)

      {

        c[i*4+j]+= a[i*4+k] * b[k*4+j];

      }

    }

  }

  return c;

}

function MatrixTransposeInverse(m)

        {

          let r = [

                0, 0, 0, 0,

                0, 0, 0, 0,

                0, 0, 0, 0,

                0, 0, 0, 0

            ];

          r[0] = m[5]*m[10]*m[15] - m[5]*m[14]*m[11] - m[6]*m[9]*m[15] + m[6]*m[13]*m[11] + m[7]*m[9]*m[14] - m[7]*m[13]*m[10];

          r[1] = -m[1]*m[10]*m[15] + m[1]*m[14]*m[11] + m[2]*m[9]*m[15] - m[2]*m[13]*m[11] - m[3]*m[9]*m[14] + m[3]*m[13]*m[10];

          r[2] = m[1]*m[6]*m[15] - m[1]*m[14]*m[7] - m[2]*m[5]*m[15] + m[2]*m[13]*m[7] + m[3]*m[5]*m[14] - m[3]*m[13]*m[6];

          r[3] = -m[1]*m[6]*m[11] + m[1]*m[10]*m[7] + m[2]*m[5]*m[11] - m[2]*m[9]*m[7] - m[3]*m[5]*m[10] + m[3]*m[9]*m[6];



          r[4] = -m[4]*m[10]*m[15] + m[4]*m[14]*m[11] + m[6]*m[8]*m[15] - m[6]*m[12]*m[11] - m[7]*m[8]*m[14] + m[7]*m[12]*m[10];

          r[5] = m[0]*m[10]*m[15] - m[0]*m[14]*m[11] - m[2]*m[8]*m[15] + m[2]*m[12]*m[11] + m[3]*m[8]*m[14] - m[3]*m[12]*m[10];

          r[6] = -m[0]*m[6]*m[15] + m[0]*m[14]*m[7] + m[2]*m[4]*m[15] - m[2]*m[12]*m[7] - m[3]*m[4]*m[14] + m[3]*m[12]*m[6];

          r[7] = m[0]*m[6]*m[11] - m[0]*m[10]*m[7] - m[2]*m[4]*m[11] + m[2]*m[8]*m[7] + m[3]*m[4]*m[10] - m[3]*m[8]*m[6];



          r[8] = m[4]*m[9]*m[15] - m[4]*m[13]*m[11] - m[5]*m[8]*m[15] + m[5]*m[12]*m[11] + m[7]*m[8]*m[13] - m[7]*m[12]*m[9];

          r[9] = -m[0]*m[9]*m[15] + m[0]*m[13]*m[11] + m[1]*m[8]*m[15] - m[1]*m[12]*m[11] - m[3]*m[8]*m[13] + m[3]*m[12]*m[9];

          r[10] = m[0]*m[5]*m[15] - m[0]*m[13]*m[7] - m[1]*m[4]*m[15] + m[1]*m[12]*m[7] + m[3]*m[4]*m[13] - m[3]*m[12]*m[5];

          r[11] = -m[0]*m[5]*m[11] + m[0]*m[9]*m[7] + m[1]*m[4]*m[11] - m[1]*m[8]*m[7] - m[3]*m[4]*m[9] + m[3]*m[8]*m[5];



          r[12] = -m[4]*m[9]*m[14] + m[4]*m[13]*m[10] + m[5]*m[8]*m[14] - m[5]*m[12]*m[10] - m[6]*m[8]*m[13] + m[6]*m[12]*m[9];

          r[13] = m[0]*m[9]*m[14] - m[0]*m[13]*m[10] - m[1]*m[8]*m[14] + m[1]*m[12]*m[10] + m[2]*m[8]*m[13] - m[2]*m[12]*m[9];

          r[14] = -m[0]*m[5]*m[14] + m[0]*m[13]*m[6] + m[1]*m[4]*m[14] - m[1]*m[12]*m[6] - m[2]*m[4]*m[13] + m[2]*m[12]*m[5];

          r[15] = m[0]*m[5]*m[10] - m[0]*m[9]*m[6] - m[1]*m[4]*m[10] + m[1]*m[8]*m[6] + m[2]*m[4]*m[9] - m[2]*m[8]*m[5];



          var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];

          for (var i = 0; i < 16; i++) r[i] /= det;

          

          let rt = [ r[0], r[4], r[8], r[12],

                     r[1], r[5], r[9], r[13],

                     r[2], r[6], r[10], r[14],

                     r[3], r[7], r[11], r[15]

                     ];

          

          return rt;

        }



function createRect2(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,p4x,p4y,p4z)

{

  let vertexPosition = [p1x,p1y,p1z, p2x,p2y,p2z, p4x,p4y,p4z,  //Pierwszy trójkąt

                        p1x,p1y,p1z, p4x,p4y,p4z, p3x,p3y,p3z]; //Drugi trójkąt

                        

  return vertexPosition;

}



function createRectCoords(mu,mv,dau,dav,dbu,dbv)

{

  let p1u = mu;             p1v = mv;            

  let p2u = mu + dau;       p2v = mv + dav;      

  let p3u = mu + dbu;       p3v = mv + dbv;      

  let p4u = mu + dau + dbu; p4v = mv + dav + dbv;

  

  let vertexCoord = [p1u,p1v, p2u,p2v, p4u,p4v,  //Pierwszy trójkąt

                     p1u,p1v, p4u,p4v, p3u,p3v]; //Drugi trójkąt

                        

  return vertexCoord;

}



function createRectCoords2(p1u,p1v,p2u,p2v,p3u,p3v,p4u,p4v)

{

  let vertexCoord = [p1u,p1v, p2u,p2v, p4u,p4v,  //Pierwszy trójkąt

                     p1u,p1v, p4u,p4v, p3u,p3v]; //Drugi trójkąt

                        

  return vertexCoord;

}



function createRectColor(r,g,b)

{

  let vertexColor = [r,g,b, r,g,b, r,g,b,  //Pierwszy trójkąt

                     r,g,b, r,g,b, r,g,b]; //Drugi trójkąt

                        

  return vertexColor;

}



function createNormal(p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z) //Wyznaczenie wektora normalnego dla trójkąta

{

  let v1x = p2x - p1x;

  let v1y = p2y - p1y;

  let v1z = p2z - p1z;

  

  let v2x = p3x - p1x;

  let v2y = p3y - p1y;

  let v2z = p3z - p1z;

  

  let v3x =  v1y*v2z - v1z*v2y;

  let v3y =  v1z*v2x - v1x*v2z;

  let v3z =  v1x*v2y - v1y*v2x;

  

  vl = Math.sqrt(v3x*v3x+v3y*v3y+v3z*v3z); //Obliczenie długości wektora

   

  v3x/=vl; //Normalizacja na zakreś -1 1

  v3y/=vl;

  v3z/=vl;

  

  let vertexNormal = [v3x,v3y,v3z, v3x,v3y,v3z, v3x,v3y,v3z];

  return vertexNormal;

}



function CreateShpere(x,y,z,radius, numStepsElevation, numStepsAngle)

{

  //Opis sceny 3D, położenie punktów w przestrzeni 3D w formacie X,Y,Z 

  let vertexPosition = []; //3 punkty po 3 składowe - X1,Y1,Z1, X2,Y2,Z2, X3,Y3,Z3 - 1 trójkąt

  let vertexNormal = [];

  let vertexColor = []; //3 punkty po 3 składowe - R1,G1,B1, R2,G2,B2, R3,G3,B3 - 1 trójkąt

  let vertexCoords = []; //3 punkty po 2 składowe - U1,V1, U2,V2, U3,V3 - 1 trójkąt

  

  let stepElevation = 90/numStepsElevation;

  let stepAngle = 360/numStepsAngle;

  for(let elevation=-90; elevation< 90; elevation+= stepElevation)

  {

    let radiusXZ = radius*Math.cos(elevation*Math.PI/180);

    let radiusY  = radius*Math.sin(elevation*Math.PI/180);

    

    let radiusXZ2 = radius*Math.cos((elevation+stepElevation)*Math.PI/180);

    let radiusY2  = radius*Math.sin((elevation+stepElevation)*Math.PI/180);

    

    for(let angle = 0; angle < 360; angle+= stepAngle)

    {

     

      let px1 = radiusXZ*Math.cos(angle*Math.PI/180);

      let py1 = radiusY;

      let pz1 = radiusXZ*Math.sin(angle*Math.PI/180);

      

      let px2 = radiusXZ*Math.cos((angle+stepAngle)*Math.PI/180);

      let py2 = radiusY;

      let pz2 = radiusXZ*Math.sin((angle+stepAngle)*Math.PI/180);

      

      let px3 = radiusXZ2*Math.cos(angle*Math.PI/180);

      let py3 = radiusY2;

      let pz3 = radiusXZ2*Math.sin(angle*Math.PI/180);

      

      let px4 = radiusXZ2*Math.cos((angle+stepAngle)*Math.PI/180);

      let py4 = radiusY2;

      let pz4 = radiusXZ2*Math.sin((angle+stepAngle)*Math.PI/180);

       

      vertexPosition.push(...createRect2(px1+x,py1+y,pz1+z,px2+x,py2+y,pz2+z,px3+x,py3+y,pz3+z,px4+x,py4+y,pz4+z));

      

      let p1 = Math.sqrt(px1*px1+py1*py1+pz1*pz1)

      let p2 = Math.sqrt(px2*px2+py2*py2+pz2*pz2)

      let p3 = Math.sqrt(px3*px3+py3*py3+pz3*pz3)

      let p4 = Math.sqrt(px4*px4+py4*py4+pz4*pz4)

    

     

      px1 /= p1

      py1 /= p1

      pz1 /= p1

      

      px2 /= p2

      py2 /= p2

      pz2 /= p2

      

      px3 /= p3

      py3 /= p3

      pz3 /= p3

      

      px4 /= p4

      py4 /= p4

      pz4 /= p4

      

    

      

      vertexNormal.push(...createRect2(px1,py1,pz1,px2,py2,pz2,px3,py3,pz3,px4,py4,pz4));

      

      vertexColor.push(...createRectColor(1.0,1.0,1.0));

      

      vertexCoords.push(...createRectCoords(angle/360.0,(elevation+90.0)/180.0,(stepAngle)/360.0,0.0,0.0,(stepElevation)/180.0));

    }

  }

      

      return [vertexPosition, vertexColor, vertexCoords, vertexNormal];

       

}





function startGL() 

{

  alert("StartGL");

  let canvas = document.getElementById("canvas3D"); //wyszukanie obiektu w strukturze strony 

  gl = canvas.getContext("experimental-webgl"); //pobranie kontekstu OpenGL'u z obiektu canvas

  gl.viewportWidth = canvas.width; //przypisanie wybranej przez nas rozdzielczości do systemu OpenGL

  gl.viewportHeight = canvas.height;

  

  //Kod shaderów

const vertextShaderSource = ` //Znak akcentu z przycisku tyldy - na lewo od przycisku 1 na klawiaturze

precision highp float;

attribute vec3 aVertexPosition; 

attribute vec3 aVertexColor;

attribute vec2 aVertexCoords;

attribute vec3 aVertexNormal;

uniform mat4 uVMatrix;

uniform mat4 uMMatrix;

uniform mat4 uMMatrix2;

uniform mat4 uPMatrix;

varying vec3 vPos;

varying vec3 vColor;

varying vec2 vTexUV;

varying vec3 vNormal;

void main(void) {

vec4 tmp = uMMatrix * vec4(aVertexPosition, 1.0);

gl_Position = uPMatrix * uVMatrix * tmp; //Dokonanie transformacji położenia punktów z przestrzeni 3D do przestrzeni obrazu (2D)

vPos = tmp.xyz/tmp.w;

//vPos = aVertexPosition;

vColor = aVertexColor;

vTexUV = aVertexCoords;

//vec4 tmp2 = uMMatrix * vec4(aVertexNormal, 1.0);      

//vNormal = mat3(transpose(inverse(m))) * aVertexNormal;

vNormal = normalize(mat3(uMMatrix2) * aVertexNormal);

//vNormal = aVertexNormal;

//vNormal = normalize(tmp2.xyz);

}

`;

const fragmentShaderSource = `

precision highp float;

varying vec3 vPos;

varying vec3 vColor;

varying vec2 vTexUV;

varying vec3 vNormal;

uniform sampler2D uSampler;

uniform vec3 uLightPosition;

uniform mat4 uMMatrix;

uniform float a;

void main(void) {

vec3 lightDirection = normalize(uLightPosition - vPos);

//vec4 tmp = inverse(uMMatrix) * vec4(uLightPosition,1.0);

//vec3 lightDirection = normalize(tmp.xyz - vPos);

float brightness = max(dot(vNormal*a,lightDirection), 0.0);

//gl_FragColor = vec4(vColor,1.0); //Ustalenie stałego koloru wszystkich punktów sceny

//gl_FragColor = texture2D(uSampler,vTexUV)*vec4(vColor,1.0); //Odczytanie punktu tekstury i przypisanie go jako koloru danego punktu renderowaniej figury

//gl_FragColor = vec4((vNormal+vec3(1.0,1.0,1.0))/2.0,1.0); 

gl_FragColor = clamp(texture2D(uSampler,vTexUV) * vec4(brightness,brightness,brightness,1.0),0.0,1.0);

}

`;

  let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); //Stworzenie obiektu shadera 

  let vertexShader   = gl.createShader(gl.VERTEX_SHADER);

  gl.shaderSource(fragmentShader, fragmentShaderSource); //Podpięcie źródła kodu shader

  gl.shaderSource(vertexShader, vertextShaderSource);

  gl.compileShader(fragmentShader); //Kompilacja kodu shader

  gl.compileShader(vertexShader);

  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) { //Sprawdzenie ewentualnych błedów kompilacji

    alert(gl.getShaderInfoLog(fragmentShader));

    return null;

  }

  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {

    alert(gl.getShaderInfoLog(vertexShader));

    return null;

  }

  

  shaderProgram = gl.createProgram(); //Stworzenie obiektu programu 

  gl.attachShader(shaderProgram, vertexShader); //Podpięcie obu shaderów do naszego programu wykonywanego na karcie graficznej

  gl.attachShader(shaderProgram, fragmentShader);

  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) alert("Could not initialise shaders");  //Sprawdzenie ewentualnych błedów

  

  //Opis sceny 3D, położenie punktów w przestrzeni 3D w formacie X,Y,Z 

  let vertexPosition; //3 punkty po 3 składowe - X1,Y1,Z1, X2,Y2,Z2, X3,Y3,Z3 - 1 trójkąt

  let vertexColor; //3 punkty po 3 składowe - R1,G1,B1, R2,G2,B2, R3,G3,B3 - 1 trójkąt

  let vertexCoords; //3 punkty po 2 składowe - U1,V1, U2,V2, U3,V3 - 1 trójkąt

  let vertexNormal;

  

  [vertexPosition, vertexColor, vertexCoords, vertexNormal] = CreateShpere(0,0,0,2, 12, 24);

  



  vertexPositionBuffer = gl.createBuffer(); //Stworzenie tablicy w pamieci karty graficznej

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPosition), gl.STATIC_DRAW);

  vertexPositionBuffer.itemSize = 3; //zdefiniowanie liczby współrzednych per wierzchołek

  vertexPositionBuffer.numItems = vertexPosition.length/9; //Zdefinoiowanie liczby trójkątów w naszym buforze

  

  vertexColorBuffer = gl.createBuffer();

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexColor), gl.STATIC_DRAW);

  vertexColorBuffer.itemSize = 3;

  vertexColorBuffer.numItems = vertexColor.length/9;

  

  vertexCoordsBuffer = gl.createBuffer();

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexCoordsBuffer);

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexCoords), gl.STATIC_DRAW);

  vertexCoordsBuffer.itemSize = 2;

  vertexCoordsBuffer.numItems = vertexCoords.length/6;

  

  vertexNormalBuffer = gl.createBuffer();

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormal), gl.STATIC_DRAW);

  vertexNormalBuffer.itemSize = 3;

  vertexNormalBuffer.numItems = vertexNormal.length/9;

  

  textureBuffer = gl.createTexture();

  var textureImg = new Image();

  textureImg.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg.src="sun.png"; //Nazwa obrazka

  

  textureBuffer2 = gl.createTexture();

  var textureImg2 = new Image();

  textureImg2.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer2);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg2); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg2.src="mercury.png"; //Nazwa obrazka



  textureBuffer3 = gl.createTexture();

  var textureImg3 = new Image();

  textureImg3.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer3);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg3); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg3.src="venus.png"; //Nazwa obrazka



  textureBuffer4 = gl.createTexture();

  var textureImg4 = new Image();

  textureImg4.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer4);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg4); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg4.src="earth.png"; //Nazwa obrazka



  textureBuffer5 = gl.createTexture();

  var textureImg5 = new Image();

  textureImg5.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer5);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg5); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg5.src="moon.png"; //Nazwa obrazka



  textureBuffer6 = gl.createTexture();

  var textureImg6 = new Image();

  textureImg6.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer6);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg6); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg6.src="mars.png"; //Nazwa obrazka



  textureBuffer7 = gl.createTexture();

  var textureImg7 = new Image();

  textureImg7.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer7);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg7); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg7.src="jupiter.png"; //Nazwa obrazka



  textureBuffer8 = gl.createTexture();

  var textureImg8 = new Image();

  textureImg8.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer8);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg8); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg8.src="IO.png"; //Nazwa obrazka



  textureBuffer9 = gl.createTexture();

  var textureImg9 = new Image();

  textureImg9.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer9);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg9); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg9.src="europe.png"; //Nazwa obrazka



  textureBuffer10 = gl.createTexture();

  var textureImg10 = new Image();

  textureImg10.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer10);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg10); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg10.src="ganimedes.png"; //Nazwa obrazka



  textureBuffer11 = gl.createTexture();

  var textureImg11 = new Image();

  textureImg11.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer11);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg11); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg11.src="saturn.png"; //Nazwa obrazka



  textureBuffer12 = gl.createTexture();

  var textureImg12 = new Image();

  textureImg12.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer12);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg12); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg12.src="titan.png"; //Nazwa obrazka



  textureBuffer13 = gl.createTexture();

  var textureImg13 = new Image();

  textureImg13.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer13);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg13); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg13.src="uranus.png"; //Nazwa obrazka



  textureBuffer14 = gl.createTexture();

  var textureImg14 = new Image();

  textureImg14.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer14);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg14); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg14.src="neptune.png"; //Nazwa obrazka



  textureBuffer15 = gl.createTexture();

  var textureImg15 = new Image();

  textureImg15.onload = function() { //Wykonanie kodu automatycznie po załadowaniu obrazka

    gl.bindTexture(gl.TEXTURE_2D, textureBuffer15);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg15); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  }

  textureImg15.src="tlo.png"; //Nazwa obrazka

  

  

  //Macierze opisujące położenie wirtualnej kamery w przestrzenie 3D

  let aspect = gl.viewportWidth/gl.viewportHeight;

  let fov = 45.0 * Math.PI / 180.0; //Określenie pola widzenia kamery

  let zFar = 5000.0; //Ustalenie zakresów renderowania sceny 3D (od obiektu najbliższego zNear do najdalszego zFar)

  let zNear = 0.2;

  uPMatrix = [

   1.0/(aspect*Math.tan(fov/2)),0                           ,0                         ,0                            ,

   0                         ,1.0/(Math.tan(fov/2))         ,0                         ,0                            ,

   0                         ,0                           ,-(zFar+zNear)/(zFar-zNear)  , -1,

   0                         ,0                           ,-(2*zFar*zNear)/(zFar-zNear) ,0.0,

  ];

  Tick();

} 

//let angle = 45.0; //Macierz transformacji świata - określenie położenia kamery



var angleZ = 0;

var angleY = 0;

var angleX = 0;



var angleZs = 0.0;

var angleYs = 0.0;

var angleXs = 0.0;



var angleZm = 0.0;

var angleYm = 0.0;

var angleXm = 0.0;



var angleZw = 0.0;

var angleYw = 0.0;

var angleXw = 0.0;

var angleYw2 = 0.0;



var angleZz = 0.0;

var angleYz = 0.0;

var angleXz = 0.0;



var angleZks = 0.0;

var angleYks = 0.0;

var angleXks = 0.0;



var angleZma = 0.0;

var angleYma = 0.0;

var angleXma = 0.0;



var angleZjo = 0.0;

var angleYjo = 0.0;

var angleXjo = 0.0;



var angleZio = 0.0;

var angleYio = 0.0;

var angleXio = 0.0;



var angleZeu = 0.0;

var angleYeu = 0.0;

var angleXeu = 0.0;



var angleZga = 0.0;

var angleYga = 0.0;

var angleXga = 0.0;



var angleZsa = 0.0;

var angleYsa = 0.0;

var angleXsa = 0.0;



var angleZty = 0.0;

var angleYty = 0.0;

var angleXty = 0.0;



var angleZur = 0.0;

var angleYur = 0.0;

var angleXur = 0.0;



var angleZne = 0.0;

var angleYne = 0.0;

var angleXne = 0.0;



var angleZtlo = 0.0;

var angleYtlo = 0.0;

var angleXtlo = 0.0;



//slonce

var object1x = 0.0;

var object1y = 0.0;

var object1z = 0.0;

//merkury

var object2x = 120.0;

var object2y = 0.0;

var object2z = -0.0;

//wenus

var object3x = 128.0;

var object3y = 0.0;

var object3z = -0.0;

//ziemia

var object4x = 135.0;

var object4y = 0.0;

var object4z = 0.0;

//moon

var object5x = 140.0;

var object5y = 1.0;

var object5z = 0.0;

//mars

var object6x = 145.0;

var object6y = 0.0;

var object6z = 0.0;

//jowisz

var object7x = 175.0;

var object7y = 0.0;

var object7z = 0.0;

//io

var object8x = 200.0;

var object8y = 1.0;

var object8z = 0.0;

//europa

var object9x = 200.0;

var object9y = 0.0;

var object9z =4.0;

//ganimedes

var object10x = 200.0;

var object10y = 0.0;

var object10z = -5.0;

//saturn

var object11x = 230.0;

var object11y = 0.0;

var object11z = 0.0;

//tytan

var object12x = 250.0;

var object12y = 0.0;

var object12z = 0.0;

//uran

var object13x = 270.0;

var object13y = 0.0;

var object13z = 0.0;

//neptun

var object14x = 300.0;

var object14y = 0.0;

var object14z = 0.0;



var object15x = 0.0;

var object15y = 0.0;

var object15z = 0.0;





//slonce

var scale1 = 40.0;

//merkury

var scale2 = 0.5;

//wenus

var scale3 = 1.0;

//ziemia

var scale4 = 1.5;

//ksiezyc

var scale5 = 0.3;

//mars

var scale6 = 0.9;

//jowisz

var scale7 = 10.0;

//io

var scale8 = 0.5;

//europa

var scale9 = 0.5;

//ganimedes

var scale10 = 0.8;

//saturn

var scale11 = 9.0;

//tytan

var scale12 = 1.0;

//uran

var scale13 = 6.0;

//neptun

var scale14 = 6.4;



var scale15 = 1000;



var lightX = 0;

var lightY = 0;

var lightZ = 0;



var tx= 0.0;

var ty = 0.0;

var tz = -500;



function Tick()

{  

  let uVMatrix = [

  1,0,0,0, //Macierz jednostkowa wektorow

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];





  let uMMatrix1 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMMatrix2 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMMatrix3 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



  let uMMatrix4 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



  let uMMatrix5 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];





  let uMMatrix6 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];





  let uMMatrix7 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



  let uMMatrix8 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



  let uMMatrix9 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



  let uMMatrix10 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



  let uMMatrix11 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



  let uMMatrix12 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



  let uMMatrix13 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



  let uMMatrix14 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];





  let uMMatrix15 = [

  1,0,0,0, //Macierz jednostkowa

  0,1,0,0,

  0,0,1,0,

  0,0,0,1

  ];



//slonce

  let uMVRotZs = [

  +Math.cos(angleZs*Math.PI/180.0),-Math.sin(angleZs*Math.PI/180.0),0,0,

  +Math.sin(angleZs*Math.PI/180.0),+Math.cos(angleZs*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYs = [

  +Math.cos(angleYs*Math.PI/180.0),0,-Math.sin(angleYs*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYs*Math.PI/180.0),0,+Math.cos(angleYs*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXs = [

  1,0,0,0,

  0,+Math.cos(angleXs*Math.PI/180.0),+Math.sin(angleXs*Math.PI/180.0),0,

  0,-Math.sin(angleXs*Math.PI/180.0),+Math.cos(angleXs*Math.PI/180.0),0,

  0,0,0,1

  ];



//merkury

  let uMVRotZm = [

  +Math.cos(angleZm*Math.PI/180.0),+Math.sin(angleZm*Math.PI/180.0),0,0,

  -Math.sin(angleZm*Math.PI/180.0),+Math.cos(angleZm*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYm = [

  +Math.cos(angleYm*Math.PI/180.0),0,-Math.sin(angleYm*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYm*Math.PI/180.0),0,+Math.cos(angleYm*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXm = [

  1,0,0,0,

  0,+Math.cos(angleXm*Math.PI/180.0),+Math.sin(angleXm*Math.PI/180.0),0,

  0,-Math.sin(angleXm*Math.PI/180.0),+Math.cos(angleXm*Math.PI/180.0),0,

  0,0,0,1

  ];



//wenus



  let uMVRotZw = [

  +Math.cos(angleZw*Math.PI/180.0),+Math.sin(angleZw*Math.PI/180.0),0,0,

  -Math.sin(angleZw*Math.PI/180.0),+Math.cos(angleZw*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYw = [

  +Math.cos(angleYw*Math.PI/180.0),0,-Math.sin(angleYw*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYw*Math.PI/180.0),0,+Math.cos(angleYw*Math.PI/180.0),0,

  0,0,0,1

  ];



  let uMVRotYw2 = [

  +Math.cos(angleYw2*Math.PI/180.0),0,-Math.sin(angleYw2*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYw2*Math.PI/180.0),0,+Math.cos(angleYw2*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXw = [

  1,0,0,0,

  0,+Math.cos(angleXw*Math.PI/180.0),+Math.sin(angleXw*Math.PI/180.0),0,

  0,-Math.sin(angleXw*Math.PI/180.0),+Math.cos(angleXw*Math.PI/180.0),0,

  0,0,0,1

  ];





//ziemia

  let uMVRotZz = [

  +Math.cos(angleZz*Math.PI/180.0),+Math.sin(angleZz*Math.PI/180.0),0,0,

  -Math.sin(angleZz*Math.PI/180.0),+Math.cos(angleZz*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYz = [

  +Math.cos(angleYz*Math.PI/180.0),0,-Math.sin(angleYz*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYz*Math.PI/180.0),0,+Math.cos(angleYz*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXz = [

  1,0,0,0,

  0,+Math.cos(angleXz*Math.PI/180.0),+Math.sin(angleXz*Math.PI/180.0),0,

  0,-Math.sin(angleXz*Math.PI/180.0),+Math.cos(angleXz*Math.PI/180.0),0,

  0,0,0,1

  ];





//moon



  let uMVRotZks = [

  +Math.cos(angleZks*Math.PI/180.0),+Math.sin(angleZks*Math.PI/180.0),0,0,

  -Math.sin(angleZks*Math.PI/180.0),+Math.cos(angleZks*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYks = [

  +Math.cos(angleYks*Math.PI/180.0),0,-Math.sin(angleYks*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYks*Math.PI/180.0),0,+Math.cos(angleYks*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXks = [

  1,0,0,0,

  0,+Math.cos(angleXks*Math.PI/180.0),+Math.sin(angleXks*Math.PI/180.0),0,

  0,-Math.sin(angleXks*Math.PI/180.0),+Math.cos(angleXks*Math.PI/180.0),0,

  0,0,0,1

  ];







//mars



  let uMVRotZma = [

  +Math.cos(angleZma*Math.PI/180.0),+Math.sin(angleZma*Math.PI/180.0),0,0,

  -Math.sin(angleZma*Math.PI/180.0),+Math.cos(angleZma*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYma = [

  +Math.cos(angleYma*Math.PI/180.0),0,-Math.sin(angleYma*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYma*Math.PI/180.0),0,+Math.cos(angleYma*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXma = [

  1,0,0,0,

  0,+Math.cos(angleXma*Math.PI/180.0),+Math.sin(angleXma*Math.PI/180.0),0,

  0,-Math.sin(angleXma*Math.PI/180.0),+Math.cos(angleXma*Math.PI/180.0),0,

  0,0,0,1

  ];



//jowisz







  let uMVRotZjo = [

  +Math.cos(angleZjo*Math.PI/180.0),+Math.sin(angleZjo*Math.PI/180.0),0,0,

  -Math.sin(angleZjo*Math.PI/180.0),+Math.cos(angleZjo*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYjo = [

  +Math.cos(angleYjo*Math.PI/180.0),0,-Math.sin(angleYjo*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYjo*Math.PI/180.0),0,+Math.cos(angleYjo*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXjo = [

  1,0,0,0,

  0,+Math.cos(angleXjo*Math.PI/180.0),+Math.sin(angleXjo*Math.PI/180.0),0,

  0,-Math.sin(angleXjo*Math.PI/180.0),+Math.cos(angleXjo*Math.PI/180.0),0,

  0,0,0,1

  ];



//io







  let uMVRotZio = [

  +Math.cos(angleZio*Math.PI/180.0),+Math.sin(angleZio*Math.PI/180.0),0,0,

  -Math.sin(angleZio*Math.PI/180.0),+Math.cos(angleZio*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYio = [

  +Math.cos(angleYio*Math.PI/180.0),0,-Math.sin(angleYio*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYio*Math.PI/180.0),0,+Math.cos(angleYio*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXio = [

  1,0,0,0,

  0,+Math.cos(angleXio*Math.PI/180.0),+Math.sin(angleXio*Math.PI/180.0),0,

  0,-Math.sin(angleXio*Math.PI/180.0),+Math.cos(angleXio*Math.PI/180.0),0,

  0,0,0,1

  ];





//europa

  let uMVRotZeu = [

  +Math.cos(angleZeu*Math.PI/180.0),+Math.sin(angleZeu*Math.PI/180.0),0,0,

  -Math.sin(angleZeu*Math.PI/180.0),+Math.cos(angleZeu*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  





  let uMVRotYeu = [

  +Math.cos(angleYeu*Math.PI/180.0),0,-Math.sin(angleYeu*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYeu*Math.PI/180.0),0,+Math.cos(angleYeu*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXeu = [

  1,0,0,0,

  0,+Math.cos(angleXeu*Math.PI/180.0),+Math.sin(angleXeu*Math.PI/180.0),0,

  0,-Math.sin(angleXeu*Math.PI/180.0),+Math.cos(angleXeu*Math.PI/180.0),0,

  0,0,0,1

  ];



//ganimedes



  let uMVRotZga = [

  +Math.cos(angleZga*Math.PI/180.0),+Math.sin(angleZga*Math.PI/180.0),0,0,

  -Math.sin(angleZga*Math.PI/180.0),+Math.cos(angleZga*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  





  let uMVRotYga = [

  +Math.cos(angleYga*Math.PI/180.0),0,-Math.sin(angleYga*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYga*Math.PI/180.0),0,+Math.cos(angleYga*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXga = [

  1,0,0,0,

  0,+Math.cos(angleXga*Math.PI/180.0),+Math.sin(angleXga*Math.PI/180.0),0,

  0,-Math.sin(angleXga*Math.PI/180.0),+Math.cos(angleXga*Math.PI/180.0),0,

  0,0,0,1

  ];



//saturn



let uMVRotZsa = [

  +Math.cos(angleZsa*Math.PI/180.0),+Math.sin(angleZsa*Math.PI/180.0),0,0,

  -Math.sin(angleZsa*Math.PI/180.0),+Math.cos(angleZsa*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  





  let uMVRotYsa = [

  +Math.cos(angleYsa*Math.PI/180.0),0,-Math.sin(angleYsa*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYsa*Math.PI/180.0),0,+Math.cos(angleYsa*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXsa = [

  1,0,0,0,

  0,+Math.cos(angleXsa*Math.PI/180.0),+Math.sin(angleXsa*Math.PI/180.0),0,

  0,-Math.sin(angleXsa*Math.PI/180.0),+Math.cos(angleXsa*Math.PI/180.0),0,

  0,0,0,1

  ];



  //tytan



  let uMVRotZty = [

  +Math.cos(angleZty*Math.PI/180.0),+Math.sin(angleZty*Math.PI/180.0),0,0,

  -Math.sin(angleZty*Math.PI/180.0),+Math.cos(angleZty*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  





  let uMVRotYty = [

  +Math.cos(angleYty*Math.PI/180.0),0,-Math.sin(angleYty*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYty*Math.PI/180.0),0,+Math.cos(angleYty*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXty = [

  1,0,0,0,

  0,+Math.cos(angleXty*Math.PI/180.0),+Math.sin(angleXty*Math.PI/180.0),0,

  0,-Math.sin(angleXty*Math.PI/180.0),+Math.cos(angleXty*Math.PI/180.0),0,

  0,0,0,1

  ];



//uran



let uMVRotZur = [

  +Math.cos(angleZur*Math.PI/180.0),+Math.sin(angleZur*Math.PI/180.0),0,0,

  -Math.sin(angleZur*Math.PI/180.0),+Math.cos(angleZur*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  





  let uMVRotYur = [

  +Math.cos(angleYur*Math.PI/180.0),0,-Math.sin(angleYur*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYur*Math.PI/180.0),0,+Math.cos(angleYur*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXur = [

  1,0,0,0,

  0,+Math.cos(angleXur*Math.PI/180.0),+Math.sin(angleXur*Math.PI/180.0),0,

  0,-Math.sin(angleXur*Math.PI/180.0),+Math.cos(angleXur*Math.PI/180.0),0,

  0,0,0,1

  ];



//neptun



let uMVRotZne = [

  +Math.cos(angleZne*Math.PI/180.0),+Math.sin(angleZne*Math.PI/180.0),0,0,

  -Math.sin(angleZne*Math.PI/180.0),+Math.cos(angleZne*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYne = [

  +Math.cos(angleYne*Math.PI/180.0),0,-Math.sin(angleYne*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYne*Math.PI/180.0),0,+Math.cos(angleYne*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXne = [

  1,0,0,0,

  0,+Math.cos(angleXne*Math.PI/180.0),+Math.sin(angleXne*Math.PI/180.0),0,

  0,-Math.sin(angleXne*Math.PI/180.0),+Math.cos(angleXne*Math.PI/180.0),0,

  0,0,0,1

  ];





  let uMVRotZtlo = [

  +Math.cos(angleZtlo*Math.PI/180.0),+Math.sin(angleZtlo*Math.PI/180.0),0,0,

  -Math.sin(angleZtlo*Math.PI/180.0),+Math.cos(angleZtlo*Math.PI/180.0),0,0,

  0,0,1,0,

  0,0,0,1

  ];

  

  let uMVRotYtlo = [

  +Math.cos(angleYtlo*Math.PI/180.0),0,-Math.sin(angleYtlo*Math.PI/180.0),0,

  0,1,0,0,

  +Math.sin(angleYtlo*Math.PI/180.0),0,+Math.cos(angleYtlo*Math.PI/180.0),0,

  0,0,0,1

  ];

  

  let uMVRotXtlo = [

  1,0,0,0,

  0,+Math.cos(angleXtlo*Math.PI/180.0),+Math.sin(angleXtlo*Math.PI/180.0),0,

  0,-Math.sin(angleXtlo*Math.PI/180.0),+Math.cos(angleXtlo*Math.PI/180.0),0,

  0,0,0,1

  ];



  

  let uMVTranslateZ = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  0,0,tz,1

  ];

  

  let uMVScale1 = [

  scale1,0,0,0,

  0,scale1,0,0,

  0,0,scale1,0,

  0,0,0,1

  ];

  

  let uMVScale2 = [

  scale2,0,0,0,

  0,scale2,0,0,

  0,0,scale2,0,

  0,0,0,1

  ];



  let uMVScale3 = [

  scale3,0,0,0,

  0,scale3,0,0,

  0,0,scale3,0,

  0,0,0,1

  ];





  let uMVScale4 = [

  scale4,0,0,0,

  0,scale4,0,0,

  0,0,scale4,0,

  0,0,0,1

  ];



  let uMVScale5 = [

  scale5,0,0,0,

  0,scale5,0,0,

  0,0,scale5,0,

  0,0,0,1

  ];



  let uMVScale6 = [

  scale6,0,0,0,

  0,scale6,0,0,

  0,0,scale6,0,

  0,0,0,1

  ];



  let uMVScale7 = [

  scale7,0,0,0,

  0,scale7,0,0,

  0,0,scale7,0,

  0,0,0,1

  ];



  let uMVScale8 = [

  scale8,0,0,0,

  0,scale8,0,0,

  0,0,scale8,0,

  0,0,0,1

  ];



  let uMVScale9 = [

  scale9,0,0,0,

  0,scale9,0,0,

  0,0,scale9,0,

  0,0,0,1

  ];



  let uMVScale10 = [

  scale10,0,0,0,

  0,scale10,0,0,

  0,0,scale10,0,

  0,0,0,1

  ];



  let uMVScale11 = [

  scale11,0,0,0,

  0,scale11,0,0,

  0,0,scale11,0,

  0,0,0,1

  ];





  let uMVScale12 = [

  scale12,0,0,0,

  0,scale12,0,0,

  0,0,scale12,0,

  0,0,0,1

  ];



  let uMVScale13 = [

  scale13,0,0,0,

  0,scale13,0,0,

  0,0,scale13,0,

  0,0,0,1

  ];



  let uMVScale14 = [

  scale14,0,0,0,

  0,scale14,0,0,

  0,0,scale14,0,

  0,0,0,1

  ];

  

  let uMVScale15 = [

  scale15,0,0,0,

  0,scale15,0,0,

  0,0,scale15,0,

  0,0,0,1

  ];



  let uMVObject1 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object1x,object1y,object1z,1

  ];



  let uMVObject2 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object2x,object2y,object2z,1

  ];



  let uMVObject3 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object3x,object3y,object3z,1

  ];





  let uMVObject4 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object4x,object4y,object4z,1

  ];





  let uMVObject5 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object5x,object5y,object5z,1

  ];

  



  let uMVObject6 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object6x,object6y,object6z,1

  ];





  let uMVObject7 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object7x,object7y,object7z,1

  ];

  



  let uMVObject8 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object8x,object8y,object8z,1

  ];

  



  let uMVObject9 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object9x,object9y,object9z,1

  ];

  



  let uMVObject10 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object10x,object10y,object10z,1

  ];



  let uMVObject11 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object11x,object11y,object11z,1

  ];





  let uMVObject12 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object12x,object12y,object12z,1

  ];

  



  let uMVObject13 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object13x,object13y,object13z,1

  ];



  let uMVObject14 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object14x,object14y,object14z,1

  ];

  

  let uMVObject15 = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  object15x,object15y,object15z,1

  ];

  





  let uMVTranslateX = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  tx,0,0,1

  ];



  let uMVTranslateY = [

  1,0,0,0,

  0,1,0,0,

  0,0,1,0,

  0,ty,0,1

  ];



  

   angleYs+=0.1;



   angleYm+=6.0;

   

   angleYw+=5.5;

   angleYw2-=6.0;



   angleYz+=4.0;

   angleYks+=4.0;



   angleYma+=3.5;



   angleYjo+=2.0;

   angleYio+=2.0;

   angleYeu+=2.0;

   angleYga+=2.0;



   angleYsa+=1.5;

   angleYty+=1.5;



   angleYur+=1.0;

   angleXur-=1.0;



   angleYne+=0.8;





  uMMatrix1 = MatrixMul(uMMatrix1, uMVRotYs);

  uMMatrix1 = MatrixMul(uMMatrix1, uMVScale1);

  uMMatrix1 = MatrixMul(uMMatrix1, uMVObject1); 



  uVMatrix = MatrixMul(uVMatrix, uMVTranslateX);

  uVMatrix = MatrixMul(uVMatrix, uMVTranslateZ);

  

  uMMatrix2 = MatrixMul(uMMatrix2, uMVRotYm);

  uMMatrix2 = MatrixMul(uMMatrix2, uMVScale2);

  uMMatrix2 = MatrixMul(uMMatrix2, uMVObject2); 

  uMMatrix2 = MatrixMul(uMMatrix2, uMVRotYm);     

  uMMatrix2 = MatrixMul(uMMatrix2, uMVRotYs);





  uMMatrix3 = MatrixMul(uMMatrix3, uMVRotYw);

  uMMatrix3 = MatrixMul(uMMatrix3, uMVScale3);

  uMMatrix3 = MatrixMul(uMMatrix3, uMVObject3); 

  uMMatrix3 = MatrixMul(uMMatrix3, uMVRotYw2);     

  uMMatrix3 = MatrixMul(uMMatrix3, uMVRotYs);



  uMMatrix4 = MatrixMul(uMMatrix4, uMVRotYz);

  uMMatrix4 = MatrixMul(uMMatrix4, uMVScale4);

  uMMatrix4 = MatrixMul(uMMatrix4, uMVObject4);  

  uMMatrix4 = MatrixMul(uMMatrix4, uMVRotYz);    

  uMMatrix4 = MatrixMul(uMMatrix4, uMVRotYs);



  uMMatrix5 = MatrixMul(uMMatrix5, uMVRotYks); 

  uMMatrix5 = MatrixMul(uMMatrix5, uMVScale5);

  uMMatrix5 = MatrixMul(uMMatrix5, uMVObject5);

  uMMatrix5 = MatrixMul(uMMatrix5, uMVRotYks);     

  uMMatrix5 = MatrixMul(uMMatrix5, uMVRotYs);



  uMMatrix6 = MatrixMul(uMMatrix6, uMVRotYma);

  uMMatrix6 = MatrixMul(uMMatrix6, uMVScale6);

  uMMatrix6 = MatrixMul(uMMatrix6, uMVObject6); 

  uMMatrix6 = MatrixMul(uMMatrix6, uMVRotYma);     

  uMMatrix6 = MatrixMul(uMMatrix6, uMVRotYs);



  uMMatrix7 = MatrixMul(uMMatrix7, uMVRotYjo);

  uMMatrix7 = MatrixMul(uMMatrix7, uMVScale7);

  uMMatrix7 = MatrixMul(uMMatrix7, uMVObject7); 

  uMMatrix7 = MatrixMul(uMMatrix7, uMVRotYjo);     

  uMMatrix7 = MatrixMul(uMMatrix7, uMVRotYs);



  uMMatrix8 = MatrixMul(uMMatrix8, uMVRotYio);

  uMMatrix8= MatrixMul(uMMatrix8, uMVScale8);

  uMMatrix8 = MatrixMul(uMMatrix8, uMVObject8); 

  uMMatrix8 = MatrixMul(uMMatrix8, uMVRotYio);     

  uMMatrix8 = MatrixMul(uMMatrix8, uMVRotYs);



  uMMatrix9 = MatrixMul(uMMatrix9, uMVRotYeu);

  uMMatrix9 = MatrixMul(uMMatrix9, uMVScale9);

  uMMatrix9 = MatrixMul(uMMatrix9, uMVObject9); 

  uMMatrix9 = MatrixMul(uMMatrix9, uMVRotYeu);     

  uMMatrix9 = MatrixMul(uMMatrix9, uMVRotYs);



  uMMatrix10 = MatrixMul(uMMatrix10, uMVRotYga);

  uMMatrix10 = MatrixMul(uMMatrix10, uMVScale10);

  uMMatrix10 = MatrixMul(uMMatrix10, uMVObject10);

  uMMatrix10 = MatrixMul(uMMatrix10, uMVRotYga);      

  uMMatrix10 = MatrixMul(uMMatrix10, uMVRotYs);

  

  uMMatrix11 = MatrixMul(uMMatrix11, uMVRotYsa);

  uMMatrix11 = MatrixMul(uMMatrix11, uMVScale11);

  uMMatrix11 = MatrixMul(uMMatrix11, uMVObject11); 

  uMMatrix11 = MatrixMul(uMMatrix11, uMVRotYsa);     

  uMMatrix11 = MatrixMul(uMMatrix11, uMVRotYs);



  uMMatrix12 = MatrixMul(uMMatrix12, uMVRotYty);

  uMMatrix12 = MatrixMul(uMMatrix12, uMVScale12);

  uMMatrix12 = MatrixMul(uMMatrix12, uMVObject12); 

  uMMatrix12 = MatrixMul(uMMatrix12, uMVRotYty);     

  uMMatrix12 = MatrixMul(uMMatrix12, uMVRotYs);



  uMMatrix13 = MatrixMul(uMMatrix13, uMVRotXur);

  uMMatrix13 = MatrixMul(uMMatrix13, uMVScale13);

  uMMatrix13 = MatrixMul(uMMatrix13, uMVObject13);  

  uMMatrix13 = MatrixMul(uMMatrix13, uMVRotYur);    

  uMMatrix13 = MatrixMul(uMMatrix13, uMVRotYs);



  uMMatrix14 = MatrixMul(uMMatrix14, uMVRotYne);

  uMMatrix14 = MatrixMul(uMMatrix14, uMVScale14);

  uMMatrix14 = MatrixMul(uMMatrix14, uMVObject14); 

  uMMatrix14 = MatrixMul(uMMatrix14, uMVRotYne);     

  uMMatrix14 = MatrixMul(uMMatrix14, uMVRotYs);

 

  uMMatrix15 = MatrixMul(uMMatrix15, uMVScale15);

  uMMatrix15 = MatrixMul(uMMatrix15, uMVObject15);  

  

  //Render Scene

  gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight); 

  gl.clearColor(0.0,0.0,0.0,1.0); //Wyczyszczenie obrazu kolorem czerwonym

  gl.clearDepth(1.0);             //Wyczyścienie bufora głebi najdalszym planem

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  gl.useProgram(shaderProgram)   //Użycie przygotowanego programu shaderowego

  

  gl.enable(gl.DEPTH_TEST);           // Włączenie testu głębi - obiekty bliższe mają przykrywać obiekty dalsze

  gl.depthFunc(gl.LEQUAL);            

  

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uPMatrix"), false, new Float32Array(uPMatrix)); //Wgranie macierzy kamery do pamięci karty graficznej

  

    gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uVMatrix"), false, new Float32Array(uVMatrix)); //Wgranie macierzy widoku do pamięci karty graficznej







  gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexPosition"));  //Przekazanie położenia

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);

  gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexPosition"), vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

  

  gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexColor"));  //Przekazanie kolorów

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);

  gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexColor"), vertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

  

  gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexCoords"));  //Pass the geometry

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexCoordsBuffer);

  gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexCoords"), vertexCoordsBuffer.itemSize, gl.FLOAT, false, 0, 0);

  

  gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexNormal"));  //Przekazywanie wektorów normalnych

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);

  gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexNormal"), vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

  

  gl.uniform3f(gl.getUniformLocation(shaderProgram, "uLightPosition"),lightX,lightY,lightZ);

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix1));

gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix1)));

  gl.activeTexture(gl.TEXTURE0);

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer);

  gl.uniform1i(gl.getUniformLocation(shaderProgram, "uSampler"), 0);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), -1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



  

         

  

  //2

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix2));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix2)));



  gl.bindTexture(gl.TEXTURE_2D, textureBuffer2);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania





  



  //3

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix3));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix3)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer3);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



  //4

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix4));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix4)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer4);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



    //5

    gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix5));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix5)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer5);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



  //6

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix6));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix6)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer6);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania

   



  //7

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix7));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix7)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer7);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



  //8

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix8));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix8)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer8);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



  //9

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix9));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix9)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer9);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania





  //10

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix10));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix10)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer10);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania





  //11

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix11));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix11)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer11);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania





  //12

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix12));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix12)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer12);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania





  //13

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix13));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix13)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer13);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania



   //14

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix14));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix14)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer14);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), 1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania





   //15

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMMatrix15));

  gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMMatrix15)));

  gl.bindTexture(gl.TEXTURE_2D, textureBuffer15);

  gl.uniform1f(gl.getUniformLocation(shaderProgram, "a"), -1.0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems*vertexPositionBuffer.itemSize); //Faktyczne wywołanie rendrowania





  setTimeout(Tick,50);

}

function handlekeydown(e)

{

  var speed = 3.0;



 if(e.keyCode == 38)

 {

   tz +=speed*Math.cos(angleY*Math.PI/180.0);

   tx -=speed*Math.sin(angleY*Math.PI/180.0);

 }

 if(e.keyCode == 40)

 {

   tz -=speed*Math.cos(angleY*Math.PI/180.0);

   tx +=speed*Math.sin(angleY*Math.PI/180.0);

 }

 if(e.keyCode == 37)

 {

   tz +=speed*Math.sin(angleY*Math.PI/180.0);

   tx +=speed*Math.cos(angleY*Math.PI/180.0);

 }

 if(e.keyCode == 39)

 {

   tz -=speed*Math.sin(angleY*Math.PI/180.0);

   tx -=speed*Math.cos(angleY*Math.PI/180.0);

 }



 

 //alert(e.keyCode);

 //alert(angleX);

 

}

</script>

</head>

<body onload="startGL()" onkeydown="handlekeydown(event)">

<canvas id="canvas3D" width="1440" height="900" style="border: solid black 1px"></canvas>



</body>

</html>

